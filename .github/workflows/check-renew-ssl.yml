# .github/workflows/check-renew-ssl.yml
#
# 自动化 SSL 证书检查与续签工作流 (V7 - 最终修正版)
# 采用 heredoc 语法解决 setup 任务中的 shell 引用问题。
# ==============================================================================

name: 'CertGuard: Check & Renew SSL Certificates'

on:
  schedule:
    - cron: '0 3 * * *'
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry-Run: 只检查不续签 (true/false)'
        required: true
        default: 'false'
        type: boolean
      renew_threshold_days:
        description: '续签阈值 (天)'
        required: true
        default: '10'
        type: string

jobs:
  # 任务一：准备矩阵
  # 此任务的唯一目的是从 secret 读取 JSON，并将其作为输出，供下一阶段的任务使用。
  setup:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix_json }}
    steps:
      - name: Set matrix json from secret
        id: set-matrix
        # 使用 heredoc 语法来安全地处理包含特殊字符的 secret
        run: |
          cat <<EOF >> $GITHUB_OUTPUT
          matrix_json=${{ secrets.SSH_TARGETS }}
          EOF

  # 任务二：执行检查
  check-and-renew:
    needs: setup
    strategy:
      fail-fast: false
      matrix:
        target: ${{ fromJSON(needs.setup.outputs.matrix) }}

    name: 'Check SSL on ${{ matrix.target.name }}'
    runs-on: ubuntu-latest
    
    steps:
      - name: 'Step 1: Print Job Information'
        run: |
          echo "🚀 Starting SSL certificate check for server: ${{ matrix.target.name }} (${{ matrix.target.host }})"
          if [ -n "${{ matrix.target.domain }}" ]; then
            echo "🔎 Mode: Single Domain (${{ matrix.target.domain }})"
          else
            echo "🔎 Mode: All Domains Scan"
          fi
          echo "⏰ Triggered by: ${{ github.event_name }}"
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "🔧 Dry-Run Mode: ${{ inputs.dry_run }}"
            echo "⏳ Renewal Threshold: ${{ inputs.renew_threshold_days }} days"
          else
            echo "⏳ Renewal Threshold: 10 days (default)"
          fi

      - name: 'Step 2: Execute Check & Renew Script via ssh-action'
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ matrix.target.host }}
          username: ${{ matrix.target.user }}
          key: ${{ matrix.target.ssh_key || secrets.SSH_KEY }}
          port: ${{ matrix.target.port || 22 }}
          script: |
            cat > /tmp/remote_check_and_renew.sh << 'EOF'
            ${{ env.REMOTE_SCRIPT }}
            EOF
            
            chmod +x /tmp/remote_check_and_renew.sh
            /tmp/remote_check_and_renew.sh

        env:
          DOMAIN: ${{ matrix.target.domain || '' }}
          CERT_PORT: ${{ matrix.target.port || '443' }}
          RENEW_CMD: ${{ matrix.target.renew_cmd }}
          RELOAD_CMD: ${{ matrix.target.reload_cmd }}
          CERT_PATH: ${{ matrix.target.cert_path || '' }}
          CERT_SCAN_PATH: ${{ matrix.target.cert_scan_path || '/etc/letsencrypt/live' }}
          RENEW_THRESHOLD_DAYS: ${{ github.event.inputs.renew_threshold_days || '10' }}
          DRY_RUN: ${{ github.event.inputs.dry_run || 'false' }}
          REMOTE_SCRIPT: |
            #!/bin/bash
            set -euo pipefail
            DOMAIN="${DOMAIN:-}"
            CERT_PORT="${CERT_PORT:-443}"
            RENEW_CMD="${RENEW_CMD}"
            RELOAD_CMD="${RELOAD_CMD}"
            CERT_PATH="${CERT_PATH:-}"
            CERT_SCAN_PATH="${CERT_SCAN_PATH:-/etc/letsencrypt/live}"
            RENEW_THRESHOLD_DAYS="${RENEW_THRESHOLD_DAYS:-10}"
            DRY_RUN="${DRY_RUN:-false}"
            log() { echo -e "[\033[0;32mINFO\033[0m] $(date '+%Y-%m-%d %H:%M:%S') - $1"; }
            warn() { echo -e "[\033[0;33mWARN\033[0m] $(date '+%Y-%m-%d %H:%M:%S') - $1"; }
            error() { echo -e "[\033[0;31mERROR\033[0m] $(date '+%Y-%m-%d %H:%M:%S') - $1" >&2; exit 1; }
            get_remaining_days_from_file() {
              local cert_file="$1"
              local expiry_date_str
              expiry_date_str=$(openssl x509 -enddate -noout -in "$cert_file" | cut -d= -f2)
              if [[ -z "$expiry_date_str" ]]; then echo "0"; return; fi
              local expiry_epoch
              expiry_epoch=$(date --date="$expiry_date_str" +%s)
              local current_epoch
              current_epoch=$(date +%s)
              echo $(( (expiry_epoch - current_epoch) / 86400 ))
            }
            perform_renewal_and_verification() {
              local initial_days="$1"
              local verification_mode="$2"
              local verification_target="$3"
              if [[ "$DRY_RUN" == "true" ]]; then
                log "Dry-Run 模式：跳过实际续签和重载操作。"
                exit 0
              fi
              log "正在执行续签命令: $RENEW_CMD"
              if ! eval "$RENEW_CMD"; then error "证书续签失败！请检查续签命令和相关日志。"; fi
              log "证书续签命令执行成功。"
              log "正在执行重载命令: $RELOAD_CMD"
              if ! eval "$RELOAD_CMD"; then error "服务重载失败！请检查重载命令和相关日志。"; fi
              log "服务重载命令执行成功。"
              log "等待几秒后进行二次校验..."
              sleep 5
              local new_remaining_days=0
              if [[ "$verification_mode" == "network" ]]; then
                  local expiry_date_str
                  expiry_date_str=$(echo | timeout 15 openssl s_client -servername "$verification_target" -connect "$verification_target:${CERT_PORT:-443}" 2>/dev/null | openssl x509 -enddate -noout | cut -d= -f2)
                  local expiry_epoch
                  expiry_epoch=$(date --date="$expiry_date_str" +%s)
                  local current_epoch
                  current_epoch=$(date +%s)
                  new_remaining_days=$(( (expiry_epoch - current_epoch) / 86400 ))
              else
                  new_remaining_days=$(get_remaining_days_from_file "$verification_target")
              fi
              log "续签后剩余有效期: $new_remaining_days 天"
              if [[ "$new_remaining_days" -gt "$initial_days" ]]; then
                log "\033[0;32m✅ 续签成功！证书有效期已延长。\033[0m"
              else
                error "二次校验失败！续签后证书有效期未延长。请立即手动检查！"
              fi
            }
            if [[ -n "$DOMAIN" ]]; then
              log "启动单域名检测模式: '$DOMAIN'"
              local remaining_days
              if [[ -n "$CERT_PATH" && -f "$CERT_PATH" ]]; then
                log "使用本地证书模式检测: $CERT_PATH"
                remaining_days=$(get_remaining_days_from_file "$CERT_PATH")
              else
                log "使用网络探测模式检测: $DOMAIN:$CERT_PORT"
                local expiry_date_str
                expiry_date_str=$(echo | timeout 15 openssl s_client -servername "$DOMAIN" -connect "$DOMAIN:$CERT_PORT" 2>/dev/null | openssl x509 -enddate -noout | cut -d= -f2)
                if [[ -z "$expiry_date_str" ]]; then error "无法获取 '$DOMAIN' 的证书到期日期。"; fi
                local expiry_epoch
                expiry_epoch=$(date --date="$expiry_date_str" +%s)
                local current_epoch
                current_epoch=$(date +%s)
                remaining_days=$(( (expiry_epoch - current_epoch) / 86400 ))
              fi
              log "域名 '$DOMAIN' 剩余有效期: $remaining_days 天"
              if [[ "$remaining_days" -lt "$RENEW_THRESHOLD_DAYS" ]]; then
                warn "证书剩余有效期小于 $RENEW_THRESHOLD_DAYS 天，需要续签。"
                perform_renewal_and_verification "$remaining_days" "network" "$DOMAIN"
              else
                log "\033[0;32m✅ 证书有效期正常，无需续签。\033[0m"
              fi
            else
              log "启动全盘扫描模式 (路径: $CERT_SCAN_PATH)"
              if ! [ -d "$CERT_SCAN_PATH" ]; then error "证书扫描路径 '$CERT_SCAN_PATH' 不存在或不是一个目录。"; fi
              local min_remaining_days=9999
              local soonest_expiring_cert_file=""
              local soonest_expiring_domain=""
              local cert_files
              cert_files=$(find "$CERT_SCAN_PATH" -type f -name "fullchain.pem")
              if [[ -z "$cert_files" ]]; then error "在 '$CERT_SCAN_PATH' 下未找到任何 'fullchain.pem' 文件。"; fi
              while read -r cert_file; do
                  local domain_name
                  domain_name=$(basename "$(dirname "$cert_file")")
                  local current_days
                  current_days=$(get_remaining_days_from_file "$cert_file")
                  if [[ "$current_days" -eq 0 ]]; then
                      warn "无法读取证书 '$domain_name' ($cert_file) 的有效期，已跳过。"
                      continue
                  fi
                  log "检测到域名: '$domain_name', 剩余 $current_days 天。"
                  if (( current_days < min_remaining_days )); then
                      min_remaining_days=$current_days
                      soonest_expiring_cert_file="$cert_file"
                      soonest_expiring_domain="$domain_name"
                  fi
              done <<< "$cert_files"
              if [[ "$min_remaining_days" -eq 9999 ]]; then error "扫描完成，但未能成功解析任何证书的有效期。"; fi
              log "扫描完成。最快过期的域名是 '$soonest_expiring_domain'，剩余 $min_remaining_days 天。"
              if [[ "$min_remaining_days" -lt "$RENEW_THRESHOLD_DAYS" ]]; then
                warn "存在证书剩余有效期小于 $RENEW_THRESHOLD_DAYS 天，需要触发全局续签。"
                perform_renewal_and_verification "$min_remaining_days" "file" "$soonest_expiring_cert_file"
              else
                log "\033[0;32m✅ 所有证书有效期正常，无需续签。\033[0m"
              fi
            fi
            exit 0
