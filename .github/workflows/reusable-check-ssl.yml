# .github/workflows/reusable-check-ssl.yml
# --- 子工作流 (可复用) ---
# 包含所有实际操作逻辑

name: 'Reusable: 检查并续签 SSL 证书'

on:
  workflow_call:
    inputs:
      server_name:
        description: '服务器的名称'
        required: true
        type: string
    secrets:
      SERVER_HOST:
        required: true
      SERVER_USERNAME:
        required: true
      SERVER_SSH_KEY:
        required: true
      SERVER_PORT:
        required: true

jobs:
  check-and-renew:
    name: '在 ${{ inputs.server_name }} 上检查 SSL'
    runs-on: ubuntu-latest
    steps:
      - name: '步骤 1: 打印任务信息'
        run: |
          echo "🚀 开始为服务器 ${{ inputs.server_name }} 检查 SSL 证书"

      - name: '步骤 2: 通过 SSH 执行智能续签脚本'
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USERNAME }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          port: ${{ secrets.SERVER_PORT || 22 }}
          script: |
            cat > /tmp/remote_check_and_renew.sh << 'EOF'
            ${{ env.REMOTE_SCRIPT }}
            EOF
            
            chmod +x /tmp/remote_check_and_renew.sh
            /tmp/remote_check_and_renew.sh
        env:
          RENEW_THRESHOLD_DAYS: '10' # 续签阈值固定为10天
          REMOTE_SCRIPT: |
            #!/bin/bash
            set -euo pipefail

            # --- Configuration ---
            RENEW_THRESHOLD_DAYS="${RENEW_THRESHOLD_DAYS:-10}"
            CERT_SCAN_PATH="/etc/letsencrypt/live"

            # --- Helper Functions ---
            log() { echo -e "[\033[0;32mINFO\033[0m] $(date '+%Y-%m-%d %H:%M:%S') - $1"; }
            warn() { echo -e "[\033[0;33mWARN\033[0m] $(date '+%Y-%m-%d %H:%M:%S') - $1"; }
            error() { echo -e "[\033[0;31mERROR\033[0m] $(date '+%Y-%m-%d %H:%M:%S') - $1" >&2; exit 1; }
            step_start() { log "=== 开始执行: $1 ==="; }
            step_end() { log "=== 完成执行: $1 ===\n"; }

            # --- Auto-detection Logic ---
            step_start "检测证书管理工具"
            RENEW_CMD=""
            if command -v certbot &> /dev/null; then
              log "检测到 certbot，将使用 certbot 进行续签。"
              RENEW_CMD="sudo certbot renew --quiet"
            elif [ -f "$HOME/.acme.sh/acme.sh" ]; then
              log "检测到 acme.sh，将使用 acme.sh 进行续签。"
              RENEW_CMD="\"$HOME/.acme.sh/acme.sh\" --renew-all --quiet"
            else
              error "未检测到 certbot 或 acme.sh，无法执行续签。"
            fi
            step_end "检测证书管理工具"

            step_start "检测需要重载的服务"
            # 初始化重载命令数组
            RELOAD_CMDS=""

            # 检测 Docker 容器（支持不同的命名方式）
            if command -v docker &> /dev/null; then
              step_start "Docker 环境检测"
              log "检测到 Docker 环境，开始搜索 Nginx 容器..."
              # 使用数组存储结果，避免管道子shell问题
              mapfile -t containers < <(docker ps --format "{{.ID}} {{.Names}}" | grep -iE 'nginx|proxy' || true)
              for container in "${containers[@]}"; do
                container_id=$(echo "$container" | cut -d' ' -f1)
                container_name=$(echo "$container" | cut -d' ' -f2-)
                if docker exec "$container_id" which nginx &> /dev/null; then
                  log "检测到 Nginx Docker 容器: $container_name (ID: $container_id)"
                  RELOAD_CMDS+="docker exec $container_id nginx -s reload;"
                fi
              done
              if [ ${#containers[@]} -eq 0 ]; then
                log "未找到任何 Nginx 相关的 Docker 容器"
              fi
              step_end "Docker 环境检测"
            fi

            # 检测系统服务（systemd）
            if command -v systemctl &> /dev/null; then
              step_start "Systemd 服务检测"
              # Nginx 检测
              for service in nginx nginx-full openresty; do
                if systemctl is-active --quiet "$service"; then
                  log "检测到运行中的 $service 服务"
                  RELOAD_CMDS+="sudo systemctl reload $service;"
                fi
              done

              # Apache 检测
              for service in apache2 httpd apache; do
                if systemctl is-active --quiet "$service"; then
                  log "检测到运行中的 $service 服务"
                  RELOAD_CMDS+="sudo systemctl reload $service;"
                fi
              done

              # 其他代理服务检测
              for service in caddy haproxy traefik gost; do
                if systemctl is-active --quiet "$service"; then
                  log "检测到运行中的 $service 服务"
                  if [ "$service" = "gost" ]; then
                    RELOAD_CMDS+="sudo systemctl restart $service;"  # gost 通常没有 reload
                  else
                    RELOAD_CMDS+="sudo systemctl reload $service;"
                  fi
                fi
              done
              step_end "Systemd 服务检测"
            fi

            # 检测进程（非 systemd）
            if ! command -v systemctl &> /dev/null; then
              step_start "传统进程检测"
              if pgrep -f "nginx: master process" > /dev/null; then
                log "检测到 Nginx 主进程"
                RELOAD_CMDS+="sudo nginx -s reload;"
              fi
              
              if pgrep -f "apache2" > /dev/null || pgrep -f "httpd" > /dev/null; then
                if [ -f "/etc/debian_version" ]; then
                  log "检测到 Apache2 进程 (Debian/Ubuntu)"
                  RELOAD_CMDS+="sudo apache2ctl graceful;"
                else
                  log "检测到 HTTPD 进程 (RHEL/CentOS)"
                  RELOAD_CMDS+="sudo apachectl graceful;"
                fi
              fi
              step_end "传统进程检测"
            fi

            # 移除最后一个分号
            RELOAD_CMDS="${RELOAD_CMDS%;}"

            if [ -z "${RELOAD_CMDS}" ]; then
              error "未检测到任何支持的服务 (Docker Nginx, Nginx, Apache, Gost)，无法执行重载。"
            fi

            step_end "检测需要重载的服务"

            # --- Core Logic ---
            step_start "证书扫描和有效期检查"
            get_remaining_days_from_file() {
              local cert_file="$1"
              local expiry_date_str
              expiry_date_str=$(openssl x509 -enddate -noout -in "$cert_file" | cut -d= -f2)
              if [[ -z "$expiry_date_str" ]]; then echo "0"; return; fi
              local expiry_epoch
              expiry_epoch=$(date --date="$expiry_date_str" +%s)
              local current_epoch
              current_epoch=$(date +%s)
              echo $(( (expiry_epoch - current_epoch) / 86400 ))
            }

            log "启动全盘扫描模式 (路径: $CERT_SCAN_PATH)"
            if ! [ -d "$CERT_SCAN_PATH" ]; then error "证书扫描路径 '$CERT_SCAN_PATH' 不存在或不是一个目录。"; fi

            min_remaining_days=9999
            soonest_expiring_cert_file=""
            soonest_expiring_domain=""
            
            cert_files=$(find "$CERT_SCAN_PATH" -type d -maxdepth 1 -mindepth 1 2>/dev/null | while read -r domain_dir; do
              if [[ -f "$domain_dir/fullchain.pem" ]]; then
                echo "$domain_dir/fullchain.pem"
              fi
            done)

            if [[ -z "$cert_files" ]]; then
              log "在 '$CERT_SCAN_PATH' 的子目录中未找到任何 'fullchain.pem' 文件。"
              # 检查是否存在任何域名目录
              domain_count=$(find "$CERT_SCAN_PATH" -type d -maxdepth 1 -mindepth 1 2>/dev/null | wc -l)
              if [ "$domain_count" -eq 0 ]; then
                warn "在 '$CERT_SCAN_PATH' 下未找到任何域名目录。"
              else
                warn "找到 $domain_count 个域名目录，但都不包含有效的证书文件。"
              fi
              exit 0
            fi

            while read -r cert_file; do
                domain_name=$(basename "$(dirname "$cert_file")")
                current_days=$(get_remaining_days_from_file "$cert_file")
                if [[ "$current_days" -eq 0 ]]; then
                    warn "无法读取证书 '$domain_name' ($cert_file) 的有效期，已跳过。"
                    continue
                fi
                log "检测到域名: '$domain_name', 剩余 $current_days 天。"
                if (( current_days < min_remaining_days )); then
                    min_remaining_days=$current_days
                    soonest_expiring_cert_file="$cert_file"
                    soonest_expiring_domain="$domain_name"
                fi
            done <<< "$cert_files"

            if [[ "$min_remaining_days" -eq 9999 ]]; then error "扫描完成，但未能成功解析任何证书的有效期。"; fi

            log "扫描完成。最快过期的域名是 '$soonest_expiring_domain'，剩余 $min_remaining_days 天。"
            step_end "证书扫描和有效期检查"
            if [[ "$min_remaining_days" -lt "$RENEW_THRESHOLD_DAYS" ]]; then
              warn "存在证书剩余有效期小于 $RENEW_THRESHOLD_DAYS 天，需要触发全局续签。"
              step_start "证书续签流程"
              log "正在执行续签命令: $RENEW_CMD"
              if ! eval "$RENEW_CMD"; then error "证书续签失败！请检查续签命令和相关日志。"; fi
              log "证书续签命令执行成功。"
              log "正在执行重载命令..."
              if ! eval "$RELOAD_CMDS"; then error "服务重载失败！请检查相关日志。"; fi
              log "所有检测到的服务均已重载。"
              log "等待几秒后进行二次校验..."
              sleep 5
              new_remaining_days=$(get_remaining_days_from_file "$soonest_expiring_cert_file")
              log "续签后 '$soonest_expiring_domain' 剩余有效期: $new_remaining_days 天"
              if [[ "$new_remaining_days" -gt "$min_remaining_days" ]]; then
                log "\033[0;32m✅ 续签成功！证书有效期已延长。\033[0m"
              else
                error "二次校验失败！续签后证书有效期未延长。请立即手动检查！"
              fi
              step_end "证书续签流程"
            else
              log "\033[0;32m✅ 所有证书有效期正常，无需续签。\033[0m"
            fi
            exit 0
